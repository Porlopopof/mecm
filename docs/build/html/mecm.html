

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="python" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="python" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mecm package &mdash; mecm 0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> mecm
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">mecm package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-mecm.mecm">mecm.mecm module</a></li>
<li><a class="reference internal" href="#module-mecm.leastsquares">mecm.leastsquares module</a></li>
<li><a class="reference internal" href="#module-mecm.localestimator">mecm.localestimator module</a></li>
<li><a class="reference internal" href="#module-mecm.matrixalgebra">mecm.matrixalgebra module</a></li>
<li><a class="reference internal" href="#id2">mecm.mecm module</a></li>
<li><a class="reference internal" href="#module-mecm.noise">mecm.noise module</a></li>
<li><a class="reference internal" href="#module-mecm.peacecontestimator">mecm.peacecontestimator module</a></li>
<li><a class="reference internal" href="#module-mecm.version">mecm.version module</a></li>
<li><a class="reference internal" href="#module-mecm">Module contents</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">mecm</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>mecm package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/mecm.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mecm-package">
<h1>mecm package<a class="headerlink" href="#mecm-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="mecm.tests.html">mecm.tests package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="mecm.tests.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="mecm.tests.html#mecm-tests-test-mecm-module">mecm.tests.test_mecm module</a></li>
<li class="toctree-l2"><a class="reference internal" href="mecm.tests.html#module-mecm.tests.working_example">mecm.tests.working_example module</a></li>
<li class="toctree-l2"><a class="reference internal" href="mecm.tests.html#module-mecm.tests">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-mecm.mecm">
<span id="mecm-mecm-module"></span><h2>mecm.mecm module<a class="headerlink" href="#module-mecm.mecm" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="mecm.mecm.buildSparseCov2">
<code class="descclassname">mecm.mecm.</code><code class="descname">buildSparseCov2</code><span class="sig-paren">(</span><em>R</em>, <em>p</em>, <em>N</em>, <em>form=None</em>, <em>taper='Wendland2'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#buildSparseCov2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.mecm.buildSparseCov2" title="Permalink to this definition">¶</a></dt>
<dd><p>This function constructs a sparse matrix which is a tappered, approximate
version of the covariance matrix of a stationary process of autocovariance
function R and size N x N.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> (<em>numpy array</em>) -- input autocovariance functions at each lag (size N)</li>
<li><strong>p</strong> (<em>scalar integer</em>) -- number of lags to calculate the tapered approximation of the
autocoariance function.</li>
<li><strong>N</strong> (<em>scalar integer</em>) -- Size of the complete data vector</li>
<li><strong>form</strong> (<em>character string (or None), optional</em>) -- storage format of the sparse matrix (default is None)</li>
<li><strong>taper</strong> (<em>string</em>) -- type of taper function to smoothly decrease the tapered covariance
function down to zero.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>C_tap</strong> -- Tappered covariance matrix (size N x N) with p non-zero diagonals.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">scipy.sparse matrix</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.mecm.computePrecond">
<code class="descclassname">mecm.mecm.</code><code class="descname">computePrecond</code><span class="sig-paren">(</span><em>R</em>, <em>M</em>, <em>p=10</em>, <em>ptype='sparse'</em>, <em>taper='Wendland2'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#computePrecond"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.mecm.computePrecond" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given mask and a given PSD function, the function computes the linear
operator x = C_OO^{-1} b for any vector b, where C_OO is the covariance matrix
of the observed data (at points where M==1).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> (<em>numpy array</em>) -- input autocovariance functions at each lag (size N)</li>
<li><strong>M</strong> (<em>numpy array</em>) -- mask vector</li>
<li><strong>p</strong> (<em>scalar integer</em>) -- number of lags to calculate the tapered approximation of the
autocoariance function. This is needed to pre-conditionate the conjugate
gradients.</li>
<li><strong>ptype</strong> (<em>string {'sparse','circulant'}</em>) -- specifies the type of preconditioner matrix (sparse approximation of the
covariance or circulant approximation of the covariance)</li>
<li><strong>taper</strong> (<em>string {'Wendland1','Wendland2','Spherical'}</em>) -- name of the taper function. This argument is only used if ptype = 'sparse'</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>solve</strong> -- preconditionner operator, calculating P x for all vectors x</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sparse.linalg.factorized instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.mecm.conditionalDraw">
<code class="descclassname">mecm.mecm.</code><code class="descname">conditionalDraw</code><span class="sig-paren">(</span><em>Np</em>, <em>Nit</em>, <em>S_2N</em>, <em>solver</em>, <em>z_o</em>, <em>mu_m_given_o</em>, <em>ind_obs</em>, <em>ind_mis</em>, <em>M</em>, <em>PCGalgo</em>, <em>tol=1e-07</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#conditionalDraw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.mecm.conditionalDraw" title="Permalink to this definition">¶</a></dt>
<dd><p>Function performing random draws of the complete data noise vector
conditionnaly on the observed data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Np</strong> (<em>scalar integer</em>) -- Size of the initial random vector which is drawn. The initial vector
follows a stationary distribution whose covariance matrix is circulant.
It is then truncated to N_final to obtain the desired distribution whose
covariance matrix is Toeplitz.</li>
<li><strong>Nit</strong> (<em>scalar integer</em>) -- Maximum number of conjugate gradient iterations.</li>
<li><strong>S_2N</strong> (<em>numpy array (size P &gt;= 2N)</em>) -- PSD vector</li>
<li><strong>Coo_func</strong> (<em>function</em>) -- Linear operator that calculates the matrix-to-vector product Coo x for
any vector x of size No (number of observed data points)</li>
<li><strong>solver</strong> (<em>sparse.linalg.factorized instance</em>) -- linear operator which calculates x = C_OO^{-1} b for any vector b</li>
<li><strong>z_o</strong> (<em>array_like (size No)</em>) -- vector of observed residuals</li>
<li><strong>mu_m_given_o</strong> (<em>array_like (size Nm)</em>) -- vector of conditional expectation of the missing data given the observed
data</li>
<li><strong>ind_obs</strong> (<em>array_like (size No)</em>) -- vector of chronological indices of the observed data points in the
complete data vector</li>
<li><strong>ind_mis</strong> (<em>array_like (size No)</em>) -- vector of chronological indices of the missing data points in the
complete data vector</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>tol</strong> (<em>scalar float</em>) -- Stoping criteria for the conjugate gradient algorithm, optional</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eps</strong> -- realization of the vector of conditional noise given the observed data</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array (size N)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.mecm.conditionalMonteCarlo">
<code class="descclassname">mecm.mecm.</code><code class="descname">conditionalMonteCarlo</code><span class="sig-paren">(</span><em>eps</em>, <em>solve</em>, <em>M</em>, <em>Nd</em>, <em>S_2N</em>, <em>Nit</em>, <em>PCGalgo</em>, <em>seed=None</em>, <em>tol=1e-07</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#conditionalMonteCarlo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.mecm.conditionalMonteCarlo" title="Permalink to this definition">¶</a></dt>
<dd><p>Function performing random draws of the complete data noise vector
conditionnaly on the observed data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>eps</strong> (<em>numpy array (size N)</em>) -- input vector of residuals (difference between data and model)</li>
<li><strong>solve</strong> (<em>sparse.linalg.factorized instance</em>) -- linear operator which calculates x = C_OO^{-1} b for any vector b</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>S_2N</strong> (<em>numpy array (size P &gt;= 2N)</em>) -- PSD vector</li>
<li><strong>Nit</strong> (<em>scalar integer</em>) -- Maximum number of conjugate gradient iterations.</li>
<li><strong>seed</strong> (<em>character string, optional</em>) -- Regenerate the seed with system time (if None) or chosen integer.</li>
<li><strong>tol</strong> (<em>scalar float</em>) -- Stoping criteria for the conjugate gradient algorithm, optional</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>condDraws</strong> -- Matrix whose rows are realization of the conditional noise vector</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array (size Nd x N)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.mecm.conjGradImputation">
<code class="descclassname">mecm.mecm.</code><code class="descname">conjGradImputation</code><span class="sig-paren">(</span><em>s</em>, <em>A</em>, <em>beta</em>, <em>M</em>, <em>S_2N</em>, <em>R</em>, <em>p</em>, <em>Nit</em>, <em>PCGalgo</em>, <em>tol=1e-07</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#conjGradImputation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.mecm.conjGradImputation" title="Permalink to this definition">¶</a></dt>
<dd><p>Function performing universal kriging with the model y = A beta + n
using the conjugate gradient algorithm to solve for C_OO x = b.
But this imputation function can be generalized to any solver algorithm.
See &quot;imputation&quot; function for a more general formulation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array_like (size N)</em>) -- Input signal array</li>
<li><strong>A</strong> (<em>numpy array (size N x K)</em>) -- design matrix (contains partial derivatives of signal wrt parameters)</li>
<li><strong>beta</strong> (<em>array_like (size K)</em>) -- regression parameter vector</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>S_2N</strong> (<em>numpy array (size P)</em>) -- spectrum array: value of the unilateral PSD times fs</li>
<li><strong>R</strong> (<em>numpy array (size P)</em>) -- tappered autocovariance array: value of the autocovariance at all lags</li>
<li><strong>p</strong> (<em>scalar integer</em>) -- number of lags to calculate the tapered approximation of the
autocoariance function. This is needed to pre-conditionate the conjugate
gradients.</li>
<li><strong>Nit</strong> (<em>scalar integer</em>) -- maximum number of iterations for the conjugate gradient algorithm</li>
<li><strong>tol</strong> (<em>scalar float</em>) -- tolerance criterium to stop the PCG algorithm</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>z</strong> (<em>float or ndarray</em>) -- conditional expectation of the data vector</li>
<li><strong>solve</strong> (<em>sparse.linalg.factorized instance</em>) -- linear operator which calculates x = C_OO^{-1} b for any vector b</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.mecm.maxlike">
<code class="descclassname">mecm.mecm.</code><code class="descname">maxlike</code><span class="sig-paren">(</span><em>y</em>, <em>M</em>, <em>A</em>, <em>N_it_max=15</em>, <em>eps=0.0001</em>, <em>p=20</em>, <em>Nd=10</em>, <em>N_est=1000</em>, <em>Nit_cg=200</em>, <em>tol_cg=1e-05</em>, <em>compute_cov=True</em>, <em>verbose=True</em>, <em>PCGalgo='scipy'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#maxlike"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.mecm.maxlike" title="Permalink to this definition">¶</a></dt>
<dd><p>Function estimating the regression parameters for a problem of
multivariate Gaussian maximum likelihood with missing data,
using the M-ECM algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y</strong> (<em>numpy array (size N)</em>) -- masked data vector</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>A</strong> (<em>numpy array (size N x K)</em>) -- design matrix (contains partial derivatives of signal wrt parameters)</li>
<li><strong>N_it_max</strong> (<em>scalar integer</em>) -- number of iterations of the M-ECM algorithm</li>
<li><strong>eps</strong> (<em>scalar float</em>) -- tolerance criterium to stop the algorithm (default is 1e-8)</li>
<li><strong>p</strong> (<em>scalar integer</em>) -- number of lags to calculate the tapered approximation of the
autocoariance function. This is needed to pre-conditionate the conjugate
gradients.</li>
<li><strong>Nd</strong> (<em>scalar integer</em>) -- number of Monte-Carlo draws to estimate the conditional expectation of
the noise periodogram with respect to the observed data</li>
<li><strong>N_est</strong> (<em>scalar integer</em>) -- number of frequency points where to estimate the noise power spectral
density (on a logarithmic grid)</li>
<li><strong>N_it_cg</strong> (<em>scalar integer</em>) -- maximum number of iterations for the conjugate gradient algorithm.</li>
<li><strong>tol_cg</strong> (<em>scalar float</em>) -- tolerance criterium to stop the PCG algorithm (default is 1e-7)</li>
<li><strong>verbose</strong> (<em>boolean</em>) -- if True, a message is printed at the end of each iteration, displaying
the value of the convergence criterion</li>
<li><strong>compute_cov</strong> (<em>boolean</em>) -- if True, the covariance of the estimator is computed</li>
<li><strong>PCGalgo</strong> (<em>string {'mine','scipy','scipy.bicgstab','scipy.bicg','scipy.cg','scipy.cgs'}</em>) -- Type of preconditioned conjugate gradient (PCG) algorithm to use among</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>beta_new</strong> (<em>array_like (size K)</em>) -- final value of the estimated parameter vector</li>
<li><strong>cov</strong> (<em>None or array_like (size K x K)</em>) -- estimated covariance matrix of the parameter vector. If compute_cov is
False, then cov is None</li>
<li><strong>beta</strong> (<em>array_like (size N_iterations x K)</em>) -- vector storing the updates of the parameter vector at each iteration</li>
<li><strong>y_rec</strong> (<em>array_like (size N)</em>) -- reconstructed data vector, i.e. conditional expectation of the data
given the available observations.</li>
<li><strong>I_condMean</strong> (<em>array_like (size N)</em>) -- conditional expectation of the noise periodogram</li>
<li><strong>PSD</strong> (<em>PSD_estimate class instance</em>) -- class containing all the information regarding the estimated noise PSD</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><ol class="first last upperalpha simple" start="17">
<li>Baghi et al, &quot;Gaussian regression and power spectral density estimation with missing data: The MICROSCOPE space mission as a case study,&quot; Physical Review D, vol. 93, num. 12, 2016</li>
</ol>
</td></tr>
</tbody>
</table>
<p class="rubric">Notes</p>
</dd></dl>

<dl class="function">
<dt id="mecm.mecm.mecmcovariance">
<code class="descclassname">mecm.mecm.</code><code class="descname">mecmcovariance</code><span class="sig-paren">(</span><em>A</em>, <em>M</em>, <em>S_2N</em>, <em>solve</em>, <em>PCGalgo</em>, <em>Nit=150</em>, <em>tol=1e-07</em>, <em>r=1e-15</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#mecmcovariance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.mecm.mecmcovariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Function estimating the covariance of regression parameters for a problem of
multivariate Gaussian maximum likelihood with missing data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>numpy array (size N x K)</em>) -- design matrix (contains partial derivatives of signal wrt parameters)</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>S_2N</strong> (<em>numpy array (size P &gt;= 2N)</em>) -- PSD vector</li>
<li><strong>solve</strong> (<em>sparse.linalg.factorized instance</em>) -- linear operator which calculates x = C_OO^{-1} b for any vector b</li>
<li><strong>Nit</strong> (<em>scalar integer, optional</em>) -- maximum number of iterations for the conjugate gradient algorithm.</li>
<li><strong>tol</strong> (<em>scalar float, optional</em>) -- tolerance criterium to stop the PCG algorithm (default is 1e-7)</li>
<li><strong>r</strong> (<em>scalar float, optional (default is 1e-15)</em>) -- Cutoff for small singular values when computing the inverse matrix.
Singular values smaller (in modulus) than rcond * largest_singular_value
(in modulus) are set to zero.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cov</strong> -- estimated covariance matrix of the parameter vector</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">array_like (size K x K)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.mecm.periodogram">
<code class="descclassname">mecm.mecm.</code><code class="descname">periodogram</code><span class="sig-paren">(</span><em>x_mat</em>, <em>nfft</em>, <em>wind='hanning'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#periodogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.mecm.periodogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Function computing the periodogram of the input data with a specified number
of Fourier frequencies nfft (possible zero-padding) and apodization window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x_mat</strong> (<em>numpy array (size Nd x N)</em>) -- data for which the periodogram must be computed. Can be a one-dimentional
vector or a matrix containing a time series in each row. The function
computes as many periodograms as there are rows in x_mat, and returns
a matrix of same size as x_mat.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>Per</strong> -- matrix (or vector) of periodogram</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy array (size Nd x N)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.mecm.taperCovariance">
<code class="descclassname">mecm.mecm.</code><code class="descname">taperCovariance</code><span class="sig-paren">(</span><em>h</em>, <em>theta</em>, <em>taper='Wendland1'</em>, <em>tau=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#taperCovariance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.mecm.taperCovariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculating a taper covariance that soothly goes to zero when h
goes to theta. This taper is to be mutiplied by the estimated covariance R
of the process, to discard correlations larger than theta.</p>
<p>Ref : Reinhard FURRER, Marc G. GENTON, and Douglas NYCHKA,
Covariance Tapering for Interpolation of Large Spatial Datasets,
Journal of Computational and Graphical Statistics, Volume 15, Number 3,
Pages 502–523,2006</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>h</strong> (<em>numpy array of size N</em>) -- lag</li>
<li><strong>theta</strong> (<em>scalar float</em>) -- taper parameter</li>
<li><strong>taper</strong> (<em>string {'Wendland1','Wendland2','Spherical'}</em>) -- name of the taper function</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>C_tap</strong> -- the taper covariance function values (vector of size N)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mecm.leastsquares">
<span id="mecm-leastsquares-module"></span><h2>mecm.leastsquares module<a class="headerlink" href="#module-mecm.leastsquares" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="mecm.leastsquares.pmesureMatrix">
<code class="descclassname">mecm.leastsquares.</code><code class="descname">pmesureMatrix</code><span class="sig-paren">(</span><em>Y</em>, <em>A</em>, <em>P</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/leastsquares.html#pmesureMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.leastsquares.pmesureMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculating estimator of a set of parameters with Least Squared
Estimation with ponderation matrix P in the time domain</p>
<p>References : F. METRIS &amp;  P. Bario, &quot;Moindres carres dans le domaine
frequentiel&quot;, 2013.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Y</strong> (<em>1D array_like</em>) -- observation vector (size N)</li>
<li><strong>A</strong> (<em>2D array_like</em>) -- design matrix (size N x p)</li>
<li><strong>P</strong> (<em>DD array_like</em>) -- Ponderation vector in the time domain (size N x N)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X</strong> -- estimated set of parameters (vector of size p)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.leastsquares.pmesureWeighted">
<code class="descclassname">mecm.leastsquares.</code><code class="descname">pmesureWeighted</code><span class="sig-paren">(</span><em>Y</em>, <em>A</em>, <em>P</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/leastsquares.html#pmesureWeighted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.leastsquares.pmesureWeighted" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculating estimator of a set of parameters with Least Squared
Estimation with multiplicative ponderation vector P in the time domain</p>
<p>References : F. METRIS &amp;  P. Bario, &quot;Moindres carres dans le domaine
frequentiel&quot;, 2013.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Y</strong> (<em>1D array_like</em>) -- observation vector (size N)</li>
<li><strong>A</strong> (<em>2D array_like</em>) -- design matrix (size N x p)</li>
<li><strong>P</strong> (<em>1D array_like</em>) -- Ponderation vector in the time domain (size N)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X</strong> -- estimated set of parameters (vector of size p)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.leastsquares.pmesure_optimized_TF">
<code class="descclassname">mecm.leastsquares.</code><code class="descname">pmesure_optimized_TF</code><span class="sig-paren">(</span><em>Y</em>, <em>A</em>, <em>S</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/leastsquares.html#pmesure_optimized_TF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.leastsquares.pmesure_optimized_TF" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculating the estimator of a set of parameters X with optimal
ponderation.</p>
<p>The estimator reads :
X = (A_TF*(S^-1)A_TF)^-1 A_TF* S^-1 Y_TF</p>
<p>Where S is the spectrum of the noise (assumed to be known).
A_TF = [TF] A</p>
<p>References : [1] F. METRIS &amp;  P. Bario, &quot;Moindres carres dans le domaine
frequentiel&quot;, 2013.</p>
<blockquote>
<div>[2] Catherine E. Powell, Numerical Methods for Generating</div></blockquote>
<dl class="docutils">
<dt>Realisations of Gaussian Random Fields</dt>
<dd>[3] An Efficient Algorithm for a Large Toeplitz Set of Linear</dd>
</dl>
<p>Equations, R. Jain 1979.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Y</strong> (<em>1D array_like</em>) -- observation vector (size N)</li>
<li><strong>A</strong> (<em>2D array_like</em>) -- design matrix (size N x p)</li>
<li><strong>S</strong> (<em>1D array_like</em>) -- power spectrum (size N). The covariance matrix in the Fourier domain is
assumed to be diagonal and equal to diag(S)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X</strong> -- estimated set of parameters (vector of size p)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mecm.localestimator">
<span id="mecm-localestimator-module"></span><h2>mecm.localestimator module<a class="headerlink" href="#module-mecm.localestimator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="mecm.localestimator.PSD_estimate">
<em class="property">class </em><code class="descclassname">mecm.localestimator.</code><code class="descname">PSD_estimate</code><span class="sig-paren">(</span><em>N_est</em>, <em>N</em>, <em>Npoints</em>, <em>h_min=None</em>, <em>h_max=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#PSD_estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.PSD_estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class providing methods to estimate and calculate the power spectral density
of 1-D stationary processes with continuous, smooth spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>N_est</strong> (<em>scalar integer</em>) -- number of frequency points where to estimate the noise power spectral
density (on a logarithmic grid)</li>
<li><strong>N</strong> (<em>scalar integer</em>) -- size of the analysed time series</li>
<li><strong>Npoints</strong> (<em>scalar integer</em>) -- Size of the Fourier grid on which the PSD is estimated. This means that
the PSD can be evaluated at normalized frequencies between 1/Npoints and
1/2</li>
<li><strong>h_min</strong> (<em>scalar float, optional</em>) -- minimal value of the smoothing parameter</li>
<li><strong>h_max</strong> (<em>scalar float, optional</em>) -- maximal value of the smoothing parameter</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>N_est</strong> (<em>scalar integer</em>) -- number of frequency points where to estimate the noise power spectral
density (on a logarithmic grid)</li>
<li><strong>N</strong> (<em>scalar integer</em>) -- size of the analysed time series</li>
<li><strong>f_est</strong> (<em>array_like</em>) -- vector of normalized frequencies (size N_est) at which the PSD is
estimated</li>
<li><strong>S_est</strong> (<em>array_like</em>) -- vector of PSD estimates at frequencies contained in f_est (size N_est)</li>
<li><strong>h</strong> (<em>array_like</em>) -- vector of smoothing parameter values corresponding to the PSD estimates
at frequencies contained in f_est (size N_est)</li>
<li><strong>I</strong> (<em>array_like</em>) -- periodogram of the data (size N)</li>
<li><strong>V</strong> (<em>numpy array</em>) -- normalized estimator variance: V * pi^2/6 is the estimated variance of log(S_est)</li>
<li><strong>ST</strong> (<em>array_like</em>) -- quantity used in the computation of the PSD estimates, that only depends
on the chosen kernel, the data size N and smoothing parameter h. It can
be used again for another computation involving different data of same
size.</li>
<li><strong>PSD_function</strong> (<em>function of one variable</em>) -- function giving the value of the estimated PSD at any normalized
frequency between 1/Npoints and 1/2.</li>
<li><strong>PSD_variance_function</strong> (<em>function of one variable</em>) -- function giving the value of the estimated normalized log-PSD variance at
any normalized frequency between 1/Npoints and 1/2.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mecm.localestimator.PSD_estimate.MLestimate">
<code class="descname">MLestimate</code><span class="sig-paren">(</span><em>x</em>, <em>w='hanning'</em>, <em>Niter=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#PSD_estimate.MLestimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.PSD_estimate.MLestimate" title="Permalink to this definition">¶</a></dt>
<dd><p>method computing the PSD estimate of the input data x at frequencies
fj contained in f_est, using the local maximum likelihood technique.
Calculate or update the values of the attributes S_est, PSD_function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>array_like</em>) -- input data array (size N)</li>
<li><strong>w</strong> (<em>characted string</em>) -- type of apodization window to apply</li>
<li><strong>Niter</strong> (<em>scalar integer</em>) -- number of iterations in the Newton-Raphson algorithm used to compute
the maximum likelihood estimate.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mecm.localestimator.PSD_estimate.MLestimateFromI">
<code class="descname">MLestimateFromI</code><span class="sig-paren">(</span><em>I</em>, <em>Niter=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#PSD_estimate.MLestimateFromI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.PSD_estimate.MLestimateFromI" title="Permalink to this definition">¶</a></dt>
<dd><p>method computing the PSD estimate from the input periodogram I at
frequencies fj contained in f_est, using the local maximum likelihood
technique.
Calculate or update the values of the attributes S_est, PSD_function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>I</strong> (<em>array_like</em>) -- periodogram array (size N)</li>
<li><strong>Niter</strong> (<em>scalar integer</em>) -- number of iterations in the Newton-Raphson algorithm used to compute
the maximum likelihood estimate.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mecm.localestimator.PSD_estimate.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#PSD_estimate.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.PSD_estimate.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>method calculating the value of the PSD function at either a given vector
of frequency values or on the Fourier grid of given size.
The method estimate must be called beforehand with the analysed data as
intput.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> (<em>array_like or scalar integer</em>) -- vector of frequencies value or size of the Fourier grid where to
evaluate the PSD function.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>S_est_N_sym</strong> -- vector of PSD values corresponding to specified input frequencies</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">array_like</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mecm.localestimator.PSD_estimate.calculateST">
<code class="descname">calculateST</code><span class="sig-paren">(</span><em>f</em>, <em>h</em>, <em>N</em>, <em>ker='epa'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#PSD_estimate.calculateST"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.PSD_estimate.calculateST" title="Permalink to this definition">¶</a></dt>
<dd><p>Method calculating a kernel-dependant quantity that is necessary for the
PSD estimation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f</strong> (<em>array_like</em>) -- vector of frequencies where to estimate the PSD</li>
<li><strong>h</strong> (<em>scalar float</em>) -- smoothing parameter</li>
<li><strong>N</strong> (<em>scalar integer</em>) -- size of the analysed data</li>
<li><strong>ker</strong> (<em>{'epa','gauss'}, optional</em>) -- type of kernel smoothing function</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>ST</strong> (<em>array_like</em>) -- quantity used in the computation of the PSD estimates, that only
depends on the chosen kernel, the data size N and smoothing
parameter h. It can be used again for another computation involving
different data samples of same size.</li>
<li><strong>V</strong> (<em>numpy array</em>) -- normalized estimator variance: V * pi^2/6 is the estimated variance
of log(S_est)</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mecm.localestimator.PSD_estimate.calculateVariance">
<code class="descname">calculateVariance</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#PSD_estimate.calculateVariance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.PSD_estimate.calculateVariance" title="Permalink to this definition">¶</a></dt>
<dd><p>method calculating the value of the PSD function at either a given
vector of frequency values or on the Fourier grid of given size.
The method estimate must be called beforehand with the analysed data as
intput.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> (<em>array_like or scalar integer</em>) -- vector of frequencies value or size of the Fourier grid where to
evaluate the PSD function.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>variance_N_sym</strong> -- vector of (normalized) PSD variances corresponding to specified
input frequencies</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">array_like</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mecm.localestimator.PSD_estimate.conditionalEstimate">
<code class="descname">conditionalEstimate</code><span class="sig-paren">(</span><em>condDraws</em>, <em>wind='hanning'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#PSD_estimate.conditionalEstimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.PSD_estimate.conditionalEstimate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mecm.localestimator.PSD_estimate.confidenceInterval">
<code class="descname">confidenceInterval</code><span class="sig-paren">(</span><em>S_est</em>, <em>variance</em>, <em>alpha</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#PSD_estimate.confidenceInterval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.PSD_estimate.confidenceInterval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mecm.localestimator.PSD_estimate.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>x</em>, <em>w='hanning'</em>, <em>periodogram=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#PSD_estimate.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.PSD_estimate.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>method computing the PSD estimate of the input data x at frequencies
fj contained in f_est, using the local least-squares technique
Calculate or update the values of the attributes S_est, PSD_function,
PSD_variance_function, and possibly I</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>array_like</em>) -- Input data array (size N)</li>
<li><strong>w</strong> (<em>characted string</em>) -- type of apodization window to apply</li>
<li><strong>periodogram</strong> (<em>boolean</em>) -- if True, the periodogram is stored in the attribute &quot;I&quot;</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mecm.localestimator.PSD_estimate.estimateFromI">
<code class="descname">estimateFromI</code><span class="sig-paren">(</span><em>I</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#PSD_estimate.estimateFromI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.PSD_estimate.estimateFromI" title="Permalink to this definition">¶</a></dt>
<dd><p>method computing the PSD estimate from the values of the input
periodogram I. Calculate or update the values of the attributes S_est,
PSD_function, PSD_variance_function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>array_like</em>) -- Input data array (size N)</li>
<li><strong>w</strong> (<em>characted string</em>) -- type of apodization window to apply</li>
<li><strong>periodogram</strong> (<em>boolean</em>) -- if True, the periodogram is stored in the attribute &quot;I&quot;</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="mecm.localestimator.epanechnikovKernel">
<code class="descclassname">mecm.localestimator.</code><code class="descname">epanechnikovKernel</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#epanechnikovKernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.epanechnikovKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Epanechnikov smoothing kernel function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>y</strong> (<em>array_like</em>) -- input abscissa (size N)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ker</strong> -- value of the kernel function at y</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">array_like (size N)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.localestimator.gaussianKernel">
<code class="descclassname">mecm.localestimator.</code><code class="descname">gaussianKernel</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#gaussianKernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.gaussianKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian smoothing kernel function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>y</strong> (<em>array_like</em>) -- input abscissa (size N)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ker</strong> -- value of the kernel function at y</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">array_like (size N)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.localestimator.kernel">
<code class="descclassname">mecm.localestimator.</code><code class="descname">kernel</code><span class="sig-paren">(</span><em>y</em>, <em>kind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Smoothing kernel function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y</strong> (<em>array_like</em>) -- input data vector to smooth (size N)</li>
<li><strong>kind</strong> (<em>{'epa','ker'}</em>) -- Type of smoothing kernel</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ker(y)</strong> -- value of the kernel function at y</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">array_like (size N)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.localestimator.localLinearEstimator">
<code class="descclassname">mecm.localestimator.</code><code class="descname">localLinearEstimator</code><span class="sig-paren">(</span><em>x</em>, <em>f</em>, <em>h</em>, <em>wind='hanning'</em>, <em>ker='epa'</em>, <em>variance=True</em>, <em>ST_given=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#localLinearEstimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.localLinearEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Function estimating the power spectral density at frequencies f from a given
data log-periodogram Y using a local linear Kernel estimation with bandwidth h</p>
<p>References :
[1] Jianqing Fan and Qiwei Yao, Nonlinear Time Series (2003), p. 284
[2] Jianqing Fan and Irene Gijbels, Data-Driven Bandwidth Selection in Local
Polynomial Fitting: Variable Bandwidth and Spatial Adaptation Journal of the
Royal Statistical Society. Series B (Methodological) Vol. 57, No. 2 (1995),
pp. 371-394</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>1-D numpy array</em>) -- the intput data (time series of size N)</li>
<li><strong>f</strong> (<em>1-D numpy array or scalar</em>) -- frequency</li>
<li><strong>h</strong> (<em>array_like</em>) -- smoothing parameter vector (size J)</li>
<li><strong>wind</strong> (<em>character string</em>) -- type of apodization window to apply (hanning or rectangular)</li>
<li><strong>ker</strong> (<em>{'epa','ker'}, optional</em>) -- Type of smoothing kernel</li>
<li><strong>variance</strong> (<em>boolean (True or False), optional</em>) -- determines wether to calculate quantities required to estimate the
variance of the PSD estimate</li>
<li><strong>ST_given</strong> (<em>None or scalar (float), optional</em>) -- quantity used in the computation, that only depends on the chosen kernel
and smoothing parameter h. It can be already calcualted from a previous
computation. Otherwise, leave it as None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>S_est</strong> (<em>numpy array</em>) -- estimated spectrum (size J)</li>
<li><strong>b_est</strong> (<em>numpy array</em>) -- estimated bias (size J)</li>
<li><strong>V</strong> (<em>numpy array</em>) -- normalized estimator variance: V * pi^2/6 is the estimated variance of log(S_est)</li>
<li><strong>sigma2_0</strong> (<em>scalar float</em>) -- normalized weighted residual sum of squares</li>
<li><strong>I</strong> (<em>array_like</em>) -- periodogram of the input data (size N)</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.localestimator.localLinearEstimatorFromI">
<code class="descclassname">mecm.localestimator.</code><code class="descname">localLinearEstimatorFromI</code><span class="sig-paren">(</span><em>I</em>, <em>f</em>, <em>h</em>, <em>ker='epa'</em>, <em>variance=False</em>, <em>ST_given=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#localLinearEstimatorFromI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.localLinearEstimatorFromI" title="Permalink to this definition">¶</a></dt>
<dd><p>Function estimating the power spectral density at frequencies f from the
intput periodogram I using a local linear Kernel estimation with bandwidth h</p>
<p>References :
[1] Jianqing Fan and Qiwei Yao, Nonlinear Time Series (2003), p. 284
[2] Jianqing Fan and Irene Gijbels, Data-Driven Bandwidth Selection in Local
Polynomial Fitting: Variable Bandwidth and Spatial Adaptation Journal of the
Royal Statistical Society. Series B (Methodological) Vol. 57, No. 2 (1995),
pp. 371-394</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>I</strong> (<em>1-D numpy array of size N</em>) -- periodogram of the analysed data</li>
<li><strong>f</strong> (<em>1-D numpy array or scalar</em>) -- frequency</li>
<li><strong>h</strong> (<em>array_like</em>) -- smoothing parameter vector (size J)</li>
<li><strong>wind</strong> (<em>character string</em>) -- type of apodization window to apply (hanning or rectangular)</li>
<li><strong>ker</strong> (<em>{'epa','ker'}, optional</em>) -- Type of smoothing kernel</li>
<li><strong>variance</strong> (<em>boolean (True or False), optional</em>) -- determines wether to calculate quantities required to estimate the
variance of the PSD estimate</li>
<li><strong>ST_given</strong> (<em>None or scalar (float), optional</em>) -- quantity used in the computation, that only depends on the chosen kernel
and smoothing parameter h. It can be already calcualted from a previous
computation. Otherwise, leave it as None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>S_est</strong> (<em>numpy array</em>) -- estimated spectrum (size J)</li>
<li><strong>b_est</strong> (<em>numpy array</em>) -- estimated bias (size J)</li>
<li><strong>V</strong> (<em>numpy array</em>) -- normalized estimator variance: V * pi^2/6 is the estimated variance of log(S_est)</li>
<li><strong>sigma2_0</strong> (<em>scalar float</em>) -- normalized weighted residual sum of squares</li>
<li><strong>ST</strong> (<em>array_like</em>) -- quantity used in the computation, that only depends on the chosen kernel,
the data size N and smoothing parameter h. It can be used again for
another computation involving different data of same size.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.localestimator.localLinearEstimatorFromY">
<code class="descclassname">mecm.localestimator.</code><code class="descname">localLinearEstimatorFromY</code><span class="sig-paren">(</span><em>Y</em>, <em>f0</em>, <em>h</em>, <em>ker='epa'</em>, <em>variance=True</em>, <em>ST_given=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#localLinearEstimatorFromY"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.localLinearEstimatorFromY" title="Permalink to this definition">¶</a></dt>
<dd><p>Function estimating the power spectral density at frequencies f from a given
data log-periodogram Y using a local linear Kernel estimation with bandwidth h</p>
<p>References :
[1] Jianqing Fan and Qiwei Yao, Nonlinear Time Series (2003), p. 284
[2] Jianqing Fan and Irene Gijbels, Data-Driven Bandwidth Selection in Local
Polynomial Fitting: Variable Bandwidth and Spatial Adaptation Journal of the
Royal Statistical Society. Series B (Methodological) Vol. 57, No. 2 (1995),
pp. 371-394</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Y</strong> (<em>1-D numpy array of size N</em>) -- log-periodogram of the analysed data</li>
<li><strong>f0</strong> (<em>1-D numpy array or scalar</em>) -- vector of frequencies where to estimate the PSD</li>
<li><strong>h</strong> (<em>array_like</em>) -- smoothing parameter vector (size J)</li>
<li><strong>wind</strong> (<em>character string</em>) -- type of apodization window to apply (hanning or rectangular)</li>
<li><strong>ker</strong> (<em>{'epa','ker'}, optional</em>) -- Type of smoothing kernel</li>
<li><strong>variance</strong> (<em>boolean (True or False), optional</em>) -- determines wether to calculate quantities required to estimate the
variance of the PSD estimate</li>
<li><strong>ST_given</strong> (<em>None or scalar (float), optional</em>) -- quantity used in the computation, that only depends on the chosen kernel
and smoothing parameter h. It can be already calcualted from a previous
computation. Otherwise, leave it as None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>S_est</strong> (<em>numpy array</em>) -- estimated spectrum (size J)</li>
<li><strong>b_est</strong> (<em>numpy array</em>) -- estimated bias (size J)</li>
<li><strong>V</strong> (<em>numpy array</em>) -- normalized estimator variance: V * pi^2/6 is the estimated variance of log(S_est)</li>
<li><strong>sigma2_0</strong> (<em>scalar float</em>) -- normalized weighted residual sum of squares</li>
<li><strong>ST</strong> (<em>array_like</em>) -- quantity used in the computation, that only depends on the chosen kernel,
the data size N and smoothing parameter h. It can be used again for
another computation involving different data of same size.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.localestimator.localLinearSmoother">
<code class="descclassname">mecm.localestimator.</code><code class="descname">localLinearSmoother</code><span class="sig-paren">(</span><em>data</em>, <em>f</em>, <em>fj</em>, <em>h</em>, <em>ker='epa'</em>, <em>variance=False</em>, <em>ST_given=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#localLinearSmoother"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.localLinearSmoother" title="Permalink to this definition">¶</a></dt>
<dd><p>Function computing the local linear estimate of the input data at points
fj, given that the input data are available at points f.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>array_like</em>) -- Input data array (size N)</li>
<li><strong>f</strong> (<em>array_like</em>) -- Abscissa correponding to the input data (size N)</li>
<li><strong>fj</strong> (<em>array_like</em>) -- Abscissa correponding to the output estimate (size J)</li>
<li><strong>h</strong> (<em>array_like</em>) -- smoothing parameter vector (size J)</li>
<li><strong>ker</strong> (<em>{'epa','ker'}, optional</em>) -- Type of smoothing kernel</li>
<li><strong>variance</strong> (<em>boolean, optional</em>) -- If True the estiamated variance of the local linear estimate is provided
as an output</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>m_est</strong> (<em>array_like</em>) -- Output estimated smooth function (intersect points, size J)</li>
<li><strong>b_est</strong> (<em>array_like</em>) -- Output estimated slopes (size J)</li>
<li><strong>V</strong> (<em>array_like</em>) -- normalized variance of the estimate (size J)</li>
<li><strong>sigma2_0</strong> (<em>scalar float</em>) -- normalized weighted residual sum of squares
V * pi^2/6</li>
<li><strong>ST</strong> (<em>array_like</em>) -- kernel-dependant quantity that does not depend on the data (may be
useful to perform several calculations with the same kernel and data size)</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.localestimator.localMLEstimatorFromI">
<code class="descclassname">mecm.localestimator.</code><code class="descname">localMLEstimatorFromI</code><span class="sig-paren">(</span><em>I</em>, <em>f</em>, <em>h</em>, <em>ker='epa'</em>, <em>Niter=1</em>, <em>ST_given=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#localMLEstimatorFromI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.localMLEstimatorFromI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="mecm.localestimator.nextpow2">
<code class="descclassname">mecm.localestimator.</code><code class="descname">nextpow2</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/localestimator.html#nextpow2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.localestimator.nextpow2" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the lowest integer q such that y = &lt;2^q (next power of 2)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>y</strong> (<em>scalar integer</em>) -- any positive number (usually the size of the data set)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>q</strong> -- the lowest integer q such 2^q is greater or equal than the input number</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">scalar integer</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mecm.matrixalgebra">
<span id="mecm-matrixalgebra-module"></span><h2>mecm.matrixalgebra module<a class="headerlink" href="#module-mecm.matrixalgebra" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="mecm.matrixalgebra.PCGsolve">
<code class="descclassname">mecm.matrixalgebra.</code><code class="descname">PCGsolve</code><span class="sig-paren">(</span><em>ind_obs</em>, <em>M</em>, <em>S_2N</em>, <em>b</em>, <em>x0</em>, <em>tol</em>, <em>maxiter</em>, <em>Psolver</em>, <em>PCGalgo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/matrixalgebra.html#PCGsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.matrixalgebra.PCGsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that solves the problem Ax = b by calling iterative algorithms, using
user-specified methods.
Where A can be written as A = W_o F* D F W_o^T</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ind_obs</strong> (<em>array_like</em>) -- array of size N_o or list containing the chronological indices of the values
contained in the observed data vector in the complete data vector</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>S_2N</strong> (<em>numpy array (size P &gt;= 2N)</em>) -- PSD vector</li>
<li><strong>b</strong> (<em>numpy array</em>) -- vector of size N_o containing the right-hand side of linear system to solve</li>
<li><strong>x0</strong> (<em>numpy array</em>) -- vector of size N_o: first guess for the linear system to be solved</li>
<li><strong>tol</strong> (<em>scalar float</em>) -- stopping criterium for the preconditioned conjugate gradient algorithm</li>
<li><strong>Psolver</strong> (<em>sparse.linalg.factorized instance</em>) -- preconditionner matrix: linear operator which calculates an approximation
of the solution: u_approx = C_OO^{-1} b for any vector b</li>
<li><strong>PCGalgo</strong> (<em>string {'mine','scipy','scipy.bicgstab','scipy.bicg','scipy.cg','scipy.cgs'}</em>) -- Type of preconditioned conjugate gradient (PCG) algorithm to use among</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>u</strong> -- approximate solution of the linear system</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.matrixalgebra.covLinearOp">
<code class="descclassname">mecm.matrixalgebra.</code><code class="descname">covLinearOp</code><span class="sig-paren">(</span><em>ind_in</em>, <em>ind_out</em>, <em>M</em>, <em>S_2N</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/matrixalgebra.html#covLinearOp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.matrixalgebra.covLinearOp" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a linear operator object that computes the operation C * v
for any vector v, where C is a covariance matrix.</p>
<p>Linear operator that calculate Com y_in assuming that we can write:</p>
<p>Com = M_o F* Lambda F M_m^T</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y_in</strong> (<em>numpy array</em>) -- input data vector</li>
<li><strong>ind_in</strong> (<em>array_like</em>) -- array or list containing the chronological indices of the values
contained in the input vector in the complete data vector</li>
<li><strong>ind_out</strong> (<em>array_like</em>) -- array or list containing the chronological indices of the values
contained in the output vector in the complete data vector</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>S_2N</strong> (<em>numpy array (size P &gt;= 2N)</em>) -- PSD vector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Coi_op</strong> -- linear opreator that computes the vector y_out = Com * y_in for any
vector of size N_in</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">scipy.sparse.linalg.LinearOperator instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.matrixalgebra.innerPrecondBiCGSTAB">
<code class="descclassname">mecm.matrixalgebra.</code><code class="descname">innerPrecondBiCGSTAB</code><span class="sig-paren">(</span><em>result</em>, <em>x0</em>, <em>B</em>, <em>A_func</em>, <em>Nit</em>, <em>stp</em>, <em>P</em>, <em>PCGalgo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/matrixalgebra.html#innerPrecondBiCGSTAB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.matrixalgebra.innerPrecondBiCGSTAB" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner function of the multithreading process.
This is used to solve the linear system
X = A^-1 B where B is a matrix, by applying the preconditioned stabilized
bi-conjuage gradient algorithm to each rows of B</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>result</strong> (<em>2D numpy array</em>) -- the result X that will be uptdated (can be empty at the beginning)</li>
<li><strong>x0</strong> (<em>numpy array of size No</em>) -- initial guess for the solution (can be zeros(No) array)</li>
<li><strong>B</strong> (<em>2D numpy array</em>) -- Matrix of observed vectors (right hand side of the system)</li>
<li><strong>A_func</strong> (<em>linear operator</em>) -- linear function of a vector x calculating A*x</li>
<li><strong>Nit</strong> (<em>scalar integer</em>) -- number of maximal iterations</li>
<li><strong>stp</strong> (<em>scalar float</em>) -- stp: stopping criteria</li>
<li><strong>P</strong> (<em>scipy.sparse. operator</em>) -- preconditionner operator, calculating Px for all vectors x</li>
<li><strong>z0_hat</strong> (<em>array_like (size N)</em>) -- first guess for solution, optional (default is None)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.matrixalgebra.make_multithread">
<code class="descclassname">mecm.matrixalgebra.</code><code class="descname">make_multithread</code><span class="sig-paren">(</span><em>inner_func</em>, <em>numthreads</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/matrixalgebra.html#make_multithread"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.matrixalgebra.make_multithread" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the precondBiCGSTAB algorithm inside <em>numthreads</em> threads, splitting its
arguments into equal-sized chunks.</p>
</dd></dl>

<dl class="function">
<dt id="mecm.matrixalgebra.make_singlethread">
<code class="descclassname">mecm.matrixalgebra.</code><code class="descname">make_singlethread</code><span class="sig-paren">(</span><em>inner_func</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/matrixalgebra.html#make_singlethread"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.matrixalgebra.make_singlethread" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the precondBiCGSTAB algorithm inside a single thread.</p>
</dd></dl>

<dl class="function">
<dt id="mecm.matrixalgebra.matPrecondBiCGSTAB">
<code class="descclassname">mecm.matrixalgebra.</code><code class="descname">matPrecondBiCGSTAB</code><span class="sig-paren">(</span><em>x0</em>, <em>B</em>, <em>A_func</em>, <em>Nit</em>, <em>stp</em>, <em>P</em>, <em>PCGalgo='scipy'</em>, <em>nthreads=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/matrixalgebra.html#matPrecondBiCGSTAB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.matrixalgebra.matPrecondBiCGSTAB" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that solves the linear system
X = A^-1 B where B is a matrix, by applying the preconditioned stabilized
bi-conjuage gradient algorithm to each rows of B
It uses multithreading.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>result</strong> (<em>2D numpy array</em>) -- the result X that will be uptdated (can be empty at the beginning)</li>
<li><strong>x0</strong> (<em>numpy array of size No</em>) -- initial guess for the solution (can be zeros(No) array)</li>
<li><strong>B</strong> (<em>2D numpy array</em>) -- Matrix of observed vectors (right hand side of the system)</li>
<li><strong>A_func</strong> (<em>linear operator</em>) -- linear function of a vector x calculating A*x</li>
<li><strong>Nit</strong> (<em>scalar integer</em>) -- number of maximal iterations</li>
<li><strong>stp</strong> (<em>scalar float</em>) -- stp: stopping criteria</li>
<li><strong>P</strong> (<em>scipy.sparse. operator</em>) -- preconditionner operator, calculating Px for all vectors x</li>
<li><strong>z0_hat</strong> (<em>array_like (size N)</em>) -- first guess for solution, optional (default is None)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X</strong> -- solution of linear systems (size No x K)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2D numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.matrixalgebra.matVectProd">
<code class="descclassname">mecm.matrixalgebra.</code><code class="descname">matVectProd</code><span class="sig-paren">(</span><em>y_in</em>, <em>ind_in</em>, <em>ind_out</em>, <em>M</em>, <em>S_2N</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/matrixalgebra.html#matVectProd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.matrixalgebra.matVectProd" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear operator that calculate Com y_in assuming that we can write:</p>
<p>Com = M_o F* Lambda F M_m^T</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y_in</strong> (<em>numpy array</em>) -- input data vector</li>
<li><strong>ind_in</strong> (<em>array_like</em>) -- array or list containing the chronological indices of the values
contained in the input vector in the complete data vector</li>
<li><strong>ind_out</strong> (<em>array_like</em>) -- array or list containing the chronological indices of the values
contained in the output vector in the complete data vector</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>N</strong> (<em>scalar integer</em>) -- Size of the complete data vector</li>
<li><strong>S_2N</strong> (<em>numpy array (size P &gt;= 2N)</em>) -- PSD vector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y_out</strong> -- y_out = Com * y_in transformed output vector of size N_out</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.matrixalgebra.matmatProd">
<code class="descclassname">mecm.matrixalgebra.</code><code class="descname">matmatProd</code><span class="sig-paren">(</span><em>A_in</em>, <em>ind_in</em>, <em>ind_out</em>, <em>M</em>, <em>S_2N</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/matrixalgebra.html#matmatProd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.matrixalgebra.matmatProd" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear operator that calculates Coi * A_in assuming that we can write:</p>
<p>Com = M_o F* Lambda F M_m^T</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y_in</strong> (<em>2D numpy array</em>) -- input matrix of size (N_in x K)</li>
<li><strong>ind_in</strong> (<em>array_like</em>) -- array or list containing the chronological indices of the values
contained in the input vector in the complete data vector (size N_in)</li>
<li><strong>ind_out</strong> (<em>array_like</em>) -- array or list containing the chronological indices of the values
contained in the output vector in the complete data vector (size N_out)</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>N</strong> (<em>scalar integer</em>) -- Size of the complete data vector</li>
<li><strong>S_2N</strong> (<em>numpy array (size P &gt;= 2N)</em>) -- PSD vector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>A_out</strong> -- Matrix (size N_out x K) equal to A_out = Com * A_in</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.matrixalgebra.precondBiCGSTAB">
<code class="descclassname">mecm.matrixalgebra.</code><code class="descname">precondBiCGSTAB</code><span class="sig-paren">(</span><em>x0</em>, <em>b</em>, <em>A_func</em>, <em>Nit</em>, <em>stp</em>, <em>P</em>, <em>z0_hat=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/matrixalgebra.html#precondBiCGSTAB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.matrixalgebra.precondBiCGSTAB" title="Permalink to this definition">¶</a></dt>
<dd><p>Function solving the linear system
x = A^-1 b
with preconditioned bi-conjuage gradient algorithm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x0</strong> (<em>numpy array of size No</em>) -- initial guess for the solution (can be zeros(No) array)</li>
<li><strong>b</strong> (<em>numpy array of size No</em>) -- observed vector (right hand side of the system)</li>
<li><strong>A_func</strong> (<em>linear operator</em>) -- linear function of a vector x calculating A*x</li>
<li><strong>Nit</strong> (<em>scalar integer</em>) -- number of maximal iterations</li>
<li><strong>stp</strong> (<em>scalar float</em>) -- stp: stopping criteria</li>
<li><strong>P</strong> (<em>scipy.sparse. operator</em>) -- preconditionner operator, calculating Px for all vectors x</li>
<li><strong>z0_hat</strong> (<em>array_like (size N)</em>) -- first guess for solution, optional (default is None)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>x</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">the reconstructed vector (numpy array of size N)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.matrixalgebra.precondLinearOp">
<code class="descclassname">mecm.matrixalgebra.</code><code class="descname">precondLinearOp</code><span class="sig-paren">(</span><em>solver</em>, <em>N_out</em>, <em>N_in</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/matrixalgebra.html#precondLinearOp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.matrixalgebra.precondLinearOp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="mecm.matrixalgebra.printPCGstatus">
<code class="descclassname">mecm.matrixalgebra.</code><code class="descname">printPCGstatus</code><span class="sig-paren">(</span><em>info</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/matrixalgebra.html#printPCGstatus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.matrixalgebra.printPCGstatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that takes the status result of the scipy.sparse.linalg.bicgstab
algorithm and print it in an understandable way.</p>
</dd></dl>

</div>
<div class="section" id="id2">
<h2>mecm.mecm module<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-mecm.mecm"></span><dl class="function">
<dt>
<code class="descclassname">mecm.mecm.</code><code class="descname">buildSparseCov2</code><span class="sig-paren">(</span><em>R</em>, <em>p</em>, <em>N</em>, <em>form=None</em>, <em>taper='Wendland2'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#buildSparseCov2"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function constructs a sparse matrix which is a tappered, approximate
version of the covariance matrix of a stationary process of autocovariance
function R and size N x N.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> (<em>numpy array</em>) -- input autocovariance functions at each lag (size N)</li>
<li><strong>p</strong> (<em>scalar integer</em>) -- number of lags to calculate the tapered approximation of the
autocoariance function.</li>
<li><strong>N</strong> (<em>scalar integer</em>) -- Size of the complete data vector</li>
<li><strong>form</strong> (<em>character string (or None), optional</em>) -- storage format of the sparse matrix (default is None)</li>
<li><strong>taper</strong> (<em>string</em>) -- type of taper function to smoothly decrease the tapered covariance
function down to zero.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>C_tap</strong> -- Tappered covariance matrix (size N x N) with p non-zero diagonals.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">scipy.sparse matrix</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">mecm.mecm.</code><code class="descname">computePrecond</code><span class="sig-paren">(</span><em>R</em>, <em>M</em>, <em>p=10</em>, <em>ptype='sparse'</em>, <em>taper='Wendland2'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#computePrecond"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>For a given mask and a given PSD function, the function computes the linear
operator x = C_OO^{-1} b for any vector b, where C_OO is the covariance matrix
of the observed data (at points where M==1).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> (<em>numpy array</em>) -- input autocovariance functions at each lag (size N)</li>
<li><strong>M</strong> (<em>numpy array</em>) -- mask vector</li>
<li><strong>p</strong> (<em>scalar integer</em>) -- number of lags to calculate the tapered approximation of the
autocoariance function. This is needed to pre-conditionate the conjugate
gradients.</li>
<li><strong>ptype</strong> (<em>string {'sparse','circulant'}</em>) -- specifies the type of preconditioner matrix (sparse approximation of the
covariance or circulant approximation of the covariance)</li>
<li><strong>taper</strong> (<em>string {'Wendland1','Wendland2','Spherical'}</em>) -- name of the taper function. This argument is only used if ptype = 'sparse'</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>solve</strong> -- preconditionner operator, calculating P x for all vectors x</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sparse.linalg.factorized instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">mecm.mecm.</code><code class="descname">conditionalDraw</code><span class="sig-paren">(</span><em>Np</em>, <em>Nit</em>, <em>S_2N</em>, <em>solver</em>, <em>z_o</em>, <em>mu_m_given_o</em>, <em>ind_obs</em>, <em>ind_mis</em>, <em>M</em>, <em>PCGalgo</em>, <em>tol=1e-07</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#conditionalDraw"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Function performing random draws of the complete data noise vector
conditionnaly on the observed data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Np</strong> (<em>scalar integer</em>) -- Size of the initial random vector which is drawn. The initial vector
follows a stationary distribution whose covariance matrix is circulant.
It is then truncated to N_final to obtain the desired distribution whose
covariance matrix is Toeplitz.</li>
<li><strong>Nit</strong> (<em>scalar integer</em>) -- Maximum number of conjugate gradient iterations.</li>
<li><strong>S_2N</strong> (<em>numpy array (size P &gt;= 2N)</em>) -- PSD vector</li>
<li><strong>Coo_func</strong> (<em>function</em>) -- Linear operator that calculates the matrix-to-vector product Coo x for
any vector x of size No (number of observed data points)</li>
<li><strong>solver</strong> (<em>sparse.linalg.factorized instance</em>) -- linear operator which calculates x = C_OO^{-1} b for any vector b</li>
<li><strong>z_o</strong> (<em>array_like (size No)</em>) -- vector of observed residuals</li>
<li><strong>mu_m_given_o</strong> (<em>array_like (size Nm)</em>) -- vector of conditional expectation of the missing data given the observed
data</li>
<li><strong>ind_obs</strong> (<em>array_like (size No)</em>) -- vector of chronological indices of the observed data points in the
complete data vector</li>
<li><strong>ind_mis</strong> (<em>array_like (size No)</em>) -- vector of chronological indices of the missing data points in the
complete data vector</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>tol</strong> (<em>scalar float</em>) -- Stoping criteria for the conjugate gradient algorithm, optional</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eps</strong> -- realization of the vector of conditional noise given the observed data</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array (size N)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">mecm.mecm.</code><code class="descname">conditionalMonteCarlo</code><span class="sig-paren">(</span><em>eps</em>, <em>solve</em>, <em>M</em>, <em>Nd</em>, <em>S_2N</em>, <em>Nit</em>, <em>PCGalgo</em>, <em>seed=None</em>, <em>tol=1e-07</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#conditionalMonteCarlo"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Function performing random draws of the complete data noise vector
conditionnaly on the observed data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>eps</strong> (<em>numpy array (size N)</em>) -- input vector of residuals (difference between data and model)</li>
<li><strong>solve</strong> (<em>sparse.linalg.factorized instance</em>) -- linear operator which calculates x = C_OO^{-1} b for any vector b</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>S_2N</strong> (<em>numpy array (size P &gt;= 2N)</em>) -- PSD vector</li>
<li><strong>Nit</strong> (<em>scalar integer</em>) -- Maximum number of conjugate gradient iterations.</li>
<li><strong>seed</strong> (<em>character string, optional</em>) -- Regenerate the seed with system time (if None) or chosen integer.</li>
<li><strong>tol</strong> (<em>scalar float</em>) -- Stoping criteria for the conjugate gradient algorithm, optional</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>condDraws</strong> -- Matrix whose rows are realization of the conditional noise vector</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array (size Nd x N)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">mecm.mecm.</code><code class="descname">conjGradImputation</code><span class="sig-paren">(</span><em>s</em>, <em>A</em>, <em>beta</em>, <em>M</em>, <em>S_2N</em>, <em>R</em>, <em>p</em>, <em>Nit</em>, <em>PCGalgo</em>, <em>tol=1e-07</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#conjGradImputation"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Function performing universal kriging with the model y = A beta + n
using the conjugate gradient algorithm to solve for C_OO x = b.
But this imputation function can be generalized to any solver algorithm.
See &quot;imputation&quot; function for a more general formulation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array_like (size N)</em>) -- Input signal array</li>
<li><strong>A</strong> (<em>numpy array (size N x K)</em>) -- design matrix (contains partial derivatives of signal wrt parameters)</li>
<li><strong>beta</strong> (<em>array_like (size K)</em>) -- regression parameter vector</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>S_2N</strong> (<em>numpy array (size P)</em>) -- spectrum array: value of the unilateral PSD times fs</li>
<li><strong>R</strong> (<em>numpy array (size P)</em>) -- tappered autocovariance array: value of the autocovariance at all lags</li>
<li><strong>p</strong> (<em>scalar integer</em>) -- number of lags to calculate the tapered approximation of the
autocoariance function. This is needed to pre-conditionate the conjugate
gradients.</li>
<li><strong>Nit</strong> (<em>scalar integer</em>) -- maximum number of iterations for the conjugate gradient algorithm</li>
<li><strong>tol</strong> (<em>scalar float</em>) -- tolerance criterium to stop the PCG algorithm</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>z</strong> (<em>float or ndarray</em>) -- conditional expectation of the data vector</li>
<li><strong>solve</strong> (<em>sparse.linalg.factorized instance</em>) -- linear operator which calculates x = C_OO^{-1} b for any vector b</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">mecm.mecm.</code><code class="descname">maxlike</code><span class="sig-paren">(</span><em>y</em>, <em>M</em>, <em>A</em>, <em>N_it_max=15</em>, <em>eps=0.0001</em>, <em>p=20</em>, <em>Nd=10</em>, <em>N_est=1000</em>, <em>Nit_cg=200</em>, <em>tol_cg=1e-05</em>, <em>compute_cov=True</em>, <em>verbose=True</em>, <em>PCGalgo='scipy'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#maxlike"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Function estimating the regression parameters for a problem of
multivariate Gaussian maximum likelihood with missing data,
using the M-ECM algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y</strong> (<em>numpy array (size N)</em>) -- masked data vector</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>A</strong> (<em>numpy array (size N x K)</em>) -- design matrix (contains partial derivatives of signal wrt parameters)</li>
<li><strong>N_it_max</strong> (<em>scalar integer</em>) -- number of iterations of the M-ECM algorithm</li>
<li><strong>eps</strong> (<em>scalar float</em>) -- tolerance criterium to stop the algorithm (default is 1e-8)</li>
<li><strong>p</strong> (<em>scalar integer</em>) -- number of lags to calculate the tapered approximation of the
autocoariance function. This is needed to pre-conditionate the conjugate
gradients.</li>
<li><strong>Nd</strong> (<em>scalar integer</em>) -- number of Monte-Carlo draws to estimate the conditional expectation of
the noise periodogram with respect to the observed data</li>
<li><strong>N_est</strong> (<em>scalar integer</em>) -- number of frequency points where to estimate the noise power spectral
density (on a logarithmic grid)</li>
<li><strong>N_it_cg</strong> (<em>scalar integer</em>) -- maximum number of iterations for the conjugate gradient algorithm.</li>
<li><strong>tol_cg</strong> (<em>scalar float</em>) -- tolerance criterium to stop the PCG algorithm (default is 1e-7)</li>
<li><strong>verbose</strong> (<em>boolean</em>) -- if True, a message is printed at the end of each iteration, displaying
the value of the convergence criterion</li>
<li><strong>compute_cov</strong> (<em>boolean</em>) -- if True, the covariance of the estimator is computed</li>
<li><strong>PCGalgo</strong> (<em>string {'mine','scipy','scipy.bicgstab','scipy.bicg','scipy.cg','scipy.cgs'}</em>) -- Type of preconditioned conjugate gradient (PCG) algorithm to use among</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>beta_new</strong> (<em>array_like (size K)</em>) -- final value of the estimated parameter vector</li>
<li><strong>cov</strong> (<em>None or array_like (size K x K)</em>) -- estimated covariance matrix of the parameter vector. If compute_cov is
False, then cov is None</li>
<li><strong>beta</strong> (<em>array_like (size N_iterations x K)</em>) -- vector storing the updates of the parameter vector at each iteration</li>
<li><strong>y_rec</strong> (<em>array_like (size N)</em>) -- reconstructed data vector, i.e. conditional expectation of the data
given the available observations.</li>
<li><strong>I_condMean</strong> (<em>array_like (size N)</em>) -- conditional expectation of the noise periodogram</li>
<li><strong>PSD</strong> (<em>PSD_estimate class instance</em>) -- class containing all the information regarding the estimated noise PSD</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><ol class="first last upperalpha simple" start="17">
<li>Baghi et al, &quot;Gaussian regression and power spectral density estimation with missing data: The MICROSCOPE space mission as a case study,&quot; Physical Review D, vol. 93, num. 12, 2016</li>
</ol>
</td></tr>
</tbody>
</table>
<p class="rubric">Notes</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">mecm.mecm.</code><code class="descname">mecmcovariance</code><span class="sig-paren">(</span><em>A</em>, <em>M</em>, <em>S_2N</em>, <em>solve</em>, <em>PCGalgo</em>, <em>Nit=150</em>, <em>tol=1e-07</em>, <em>r=1e-15</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#mecmcovariance"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Function estimating the covariance of regression parameters for a problem of
multivariate Gaussian maximum likelihood with missing data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>numpy array (size N x K)</em>) -- design matrix (contains partial derivatives of signal wrt parameters)</li>
<li><strong>M</strong> (<em>numpy array (size N)</em>) -- mask vector (with entries equal to 0 or 1)</li>
<li><strong>S_2N</strong> (<em>numpy array (size P &gt;= 2N)</em>) -- PSD vector</li>
<li><strong>solve</strong> (<em>sparse.linalg.factorized instance</em>) -- linear operator which calculates x = C_OO^{-1} b for any vector b</li>
<li><strong>Nit</strong> (<em>scalar integer, optional</em>) -- maximum number of iterations for the conjugate gradient algorithm.</li>
<li><strong>tol</strong> (<em>scalar float, optional</em>) -- tolerance criterium to stop the PCG algorithm (default is 1e-7)</li>
<li><strong>r</strong> (<em>scalar float, optional (default is 1e-15)</em>) -- Cutoff for small singular values when computing the inverse matrix.
Singular values smaller (in modulus) than rcond * largest_singular_value
(in modulus) are set to zero.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cov</strong> -- estimated covariance matrix of the parameter vector</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">array_like (size K x K)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">mecm.mecm.</code><code class="descname">periodogram</code><span class="sig-paren">(</span><em>x_mat</em>, <em>nfft</em>, <em>wind='hanning'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#periodogram"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Function computing the periodogram of the input data with a specified number
of Fourier frequencies nfft (possible zero-padding) and apodization window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x_mat</strong> (<em>numpy array (size Nd x N)</em>) -- data for which the periodogram must be computed. Can be a one-dimentional
vector or a matrix containing a time series in each row. The function
computes as many periodograms as there are rows in x_mat, and returns
a matrix of same size as x_mat.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>Per</strong> -- matrix (or vector) of periodogram</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy array (size Nd x N)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">mecm.mecm.</code><code class="descname">taperCovariance</code><span class="sig-paren">(</span><em>h</em>, <em>theta</em>, <em>taper='Wendland1'</em>, <em>tau=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/mecm.html#taperCovariance"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Function calculating a taper covariance that soothly goes to zero when h
goes to theta. This taper is to be mutiplied by the estimated covariance R
of the process, to discard correlations larger than theta.</p>
<p>Ref : Reinhard FURRER, Marc G. GENTON, and Douglas NYCHKA,
Covariance Tapering for Interpolation of Large Spatial Datasets,
Journal of Computational and Graphical Statistics, Volume 15, Number 3,
Pages 502–523,2006</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>h</strong> (<em>numpy array of size N</em>) -- lag</li>
<li><strong>theta</strong> (<em>scalar float</em>) -- taper parameter</li>
<li><strong>taper</strong> (<em>string {'Wendland1','Wendland2','Spherical'}</em>) -- name of the taper function</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>C_tap</strong> -- the taper covariance function values (vector of size N)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mecm.noise">
<span id="mecm-noise-module"></span><h2>mecm.noise module<a class="headerlink" href="#module-mecm.noise" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="mecm.noise.generateNoiseFromDSP">
<code class="descclassname">mecm.noise.</code><code class="descname">generateNoiseFromDSP</code><span class="sig-paren">(</span><em>DSP</em>, <em>fe</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/noise.html#generateNoiseFromDSP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.noise.generateNoiseFromDSP" title="Permalink to this definition">¶</a></dt>
<dd><p>Function generating a colored noise from a vector containing the DSP.
The DSP contains Np points such that Np &gt; 2N and the output noise should
only contain N points in order to avoid boundary effects. However, the
output is a 2N vector containing all the generated data. The troncature
should be done afterwards.</p>
<p>References : Timmer &amp; König, &quot;On generating power law noise&quot;, 1995</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>DSP</strong> (<em>array_like</em>) -- vector of size N_DSP continaing the noise DSP calculated at frequencies
between -fe/N_DSP and fe/N_DSP where fe is the sampling frequency and N
is the size of the time series (it will be the size of the returned
temporal noise vector b)</li>
<li><strong>N</strong> (<em>scalar integer</em>) -- Size of the output time series</li>
<li><strong>fe</strong> (<em>scalar float</em>) -- sampling frequency</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>b</strong> (<em>numpy array</em>)</li>
<li><em>temporal sample of the colored noise (size N)</em></li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.noise.symmetrize">
<code class="descclassname">mecm.noise.</code><code class="descname">symmetrize</code><span class="sig-paren">(</span><em>values</em>, <em>N_DSP</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/noise.html#symmetrize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.noise.symmetrize" title="Permalink to this definition">¶</a></dt>
<dd><p>Function returning the full symmetrized noise DSP in UNIT/sqrt(Hz)
from DSP values ranging from fe/N_DSP to fe where :
fe is the sampling frequency
N_DSP is the data size (number of required DSP points)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>values</strong> (<em>1D-array</em>) -- Positive frequencies DSP values (vector of size N_fft)</li>
<li><strong>N_DSP</strong> (<em>scalar integer</em>) -- Number of required DSP points</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>DSP</strong> -- Noise DSP (N vector)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.noise.symmetrize_shift">
<code class="descclassname">mecm.noise.</code><code class="descname">symmetrize_shift</code><span class="sig-paren">(</span><em>values</em>, <em>N</em>, <em>fe</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/noise.html#symmetrize_shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.noise.symmetrize_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Function returning the full symmetrized noise DSP in UNIT/sqrt(Hz)
from DSP values ranging from fe/N to (N_fft+1)*fe/N where :
fe is the sampling frequency
N is the data size (number of required temporal observations)
N_fft is (N-1)/2 if N is odd and N/2-1 if N is even</p>
<p>This function differs from symmetrize function in that it &quot;shifts&quot; the real DSP
by -fe/N so that the zero frequency point actually corresponds to DSP(fe/N).
This is another way to handle the singularity at zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>DSPvalues</strong> (<em>1D-array</em>) -- Positifve frequencies DSP values (vector of size N_fft)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>DSP</strong> -- Noise DSP (N vector)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mecm.peacecontestimator">
<span id="mecm-peacecontestimator-module"></span><h2>mecm.peacecontestimator module<a class="headerlink" href="#module-mecm.peacecontestimator" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="mecm.peacecontestimator.d2logSdamdaj">
<code class="descclassname">mecm.peacecontestimator.</code><code class="descname">d2logSdamdaj</code><span class="sig-paren">(</span><em>m</em>, <em>j</em>, <em>fq</em>, <em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/peacecontestimator.html#d2logSdamdaj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.peacecontestimator.d2logSdamdaj" title="Permalink to this definition">¶</a></dt>
<dd><p>Second derivatives of the log-PSD with respect to the coefficients a's</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>m</strong> (<em>scalar integer</em>) -- index of the first derivative d2 logS / dajdam</li>
<li><strong>j</strong> (<em>scalar integer</em>) -- index of the second derivative d2 logS / dajdam</li>
<li><strong>fq</strong> (<em>numpy array of size J</em>) -- frequency vector locating the bounds of the segments</li>
<li><strong>f</strong> (<em>numpy array of size N</em>) -- frequencies where to compute the PSD, in increasing order</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dlogSda</strong> -- values of the derivatives of the log-PSD calculated at frequencies f</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array size N</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.peacecontestimator.dlogSda">
<code class="descclassname">mecm.peacecontestimator.</code><code class="descname">dlogSda</code><span class="sig-paren">(</span><em>j</em>, <em>fq</em>, <em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/peacecontestimator.html#dlogSda"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.peacecontestimator.dlogSda" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivatives of the log-PSD with respect to the coefficients a's</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>j</strong> (<em>scalar integer</em>) -- index of the derivative d logS / daj</li>
<li><strong>fq</strong> (<em>numpy array of size J</em>) -- frequency vector locating the bounds of the segments</li>
<li><strong>f</strong> (<em>numpy array of size N</em>) -- frequencies where to compute the PSD, in increasing order</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dlogSda</strong> -- values of the derivatives of the log-PSD calculated at frequencies f</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array size N</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.peacecontestimator.findclosestfrequencies">
<code class="descclassname">mecm.peacecontestimator.</code><code class="descname">findclosestfrequencies</code><span class="sig-paren">(</span><em>f_in</em>, <em>f_target</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/peacecontestimator.html#findclosestfrequencies"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.peacecontestimator.findclosestfrequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Function finding the closest frequencies to f_target in the vector f_in</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f_in</strong> (<em>numpy array of size N</em>) -- input frequency vector</li>
<li><strong>f_target</strong> (<em>numpy array of size N_est</em>) -- target frequency vector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>i_out</strong> -- indices where f_in is close to f_target</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array size &lt; N_est</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mecm.peacecontestimator.jac">
<code class="descclassname">mecm.peacecontestimator.</code><code class="descname">jac</code><span class="sig-paren">(</span><em>a</em>, <em>fq</em>, <em>f</em>, <em>z_fft</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/peacecontestimator.html#jac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.peacecontestimator.jac" title="Permalink to this definition">¶</a></dt>
<dd><p>Jacobian of the log-likelihood
loglike = -1/2 * Sum_k ( log Sk + np.abs(zk)^2 /Sk  )</p>
</dd></dl>

<dl class="function">
<dt id="mecm.peacecontestimator.psdfunction">
<code class="descclassname">mecm.peacecontestimator.</code><code class="descname">psdfunction</code><span class="sig-paren">(</span><em>a</em>, <em>fq</em>, <em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mecm/peacecontestimator.html#psdfunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mecm.peacecontestimator.psdfunction" title="Permalink to this definition">¶</a></dt>
<dd><p>PSD function whose logarithm is peacewise linear</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> (<em>numpy array of size J</em>) -- coefficients of the PSD model</li>
<li><strong>fq</strong> (<em>numpy array of size J</em>) -- frequency vector locating the bounds of the segments</li>
<li><strong>f</strong> (<em>numpy array of size N</em>) -- frequencies where to compute the PSD, in increasing order</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>S</strong> -- PSD values calculated at frequencies f</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array size N</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mecm.version">
<span id="mecm-version-module"></span><h2>mecm.version module<a class="headerlink" href="#module-mecm.version" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-mecm">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-mecm" title="Permalink to this headline">¶</a></h2>
<p>mecm/__init__.py</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Quentin Baghi.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0',
            LANGUAGE:'python',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>